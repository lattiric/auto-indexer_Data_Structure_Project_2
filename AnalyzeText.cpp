//// Created by Rick Lattin on 3/5/21.//#include "AnalyzeText.h"#include "Page.h"#include <iostream>#include <iomanip>#include <fstream>AnalyzeText::AnalyzeText() {    int x = 0;}AnalyzeText::AnalyzeText(char* arg1, char* arg2, char* arg3) {      //constructor that excepts file names as parameters    file1 = arg1;    file2 = arg2;    file3 = arg3;}void AnalyzeText::fillKeywords() {              //fills keywords vector with DSStrings for the words    std::ifstream inFS;    inFS.open(file1);    if(inFS.is_open())        std::cout<<"fillKeywords worked"<<std::endl;    else        std::cout<<"fillKeywords failed to open"<<std::endl;    while(!inFS.eof()){            char temp[1000];            DSString keyWord;            inFS.getline(temp, 1000, '\n');            keyWord = temp;            keyWord = keyWord.makeLower();            keywords.insert(keyWord);        }    inFS.close();}void AnalyzeText::sortKeywords() {      //sorts the keywords vector into the keywordsOrdered vector in alphabetical order    DSString currLeast;    DSString otherWord;    int lowestIndex;    DSString switchWord;    for(int i = 0; i<keywords.getNextOpen(); i++){        currLeast = keywords[0];        switchWord = keywords[i];        for(int x = 0; x<keywords.getNextOpen(); x++){            otherWord = keywords[x];            if(otherWord < currLeast || otherWord == currLeast) {                currLeast = otherWord;                lowestIndex = x;            }        }        keywordsOrdered.insert(currLeast);        keywords[lowestIndex] = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";    }}void AnalyzeText::fillAllPages() {                  //reads all text from pages into Page objects and into the allPages vector    std::ifstream inFS;    inFS.open(file2);    if(inFS.is_open())        std::cout<<"fillAllPages worked"<<std::endl;    else        std::cout<<"fillAllPages failed to open"<<std::endl;    char line[1000];    DSString firstPageNum;    DSString pageNumber = "0";    inFS.getline(line, 1000, '\n');    while(!inFS.eof()) {        Page onePage;        bool endOfPage = false;        if(atoi(pageNumber.c_str()) > 0)                        //stops loop if page number is -1            onePage.setPageNum(pageNumber);        else if(atoi(pageNumber.c_str()) < 0){            endOfPage = true;        }        if(line[0] == '<') {            DSString DSLine = line;            DSLine = DSLine.substring(1,DSLine.getLength()-3);       //takes first page number            firstPageNum = DSLine;        }        while(!endOfPage) {                         //gets the text and page number on each page            char textLine[1000];            inFS.getline(textLine, 1000, '\n');            if(textLine[0] == '<'){                endOfPage = true;                DSString DSTextline = textLine;                DSTextline = DSTextline.substring(1,DSTextline.getLength()-3);      //takes other page numbers                pageNumber = DSTextline;            }            else {                DSString lowerText = textLine;                lowerText = lowerText.makeLower();                onePage.getPageWords().insert(lowerText.c_str());            }        }        allPages.insert(onePage);    }    allPages[0].setPageNum(firstPageNum);    std::cout<<"testing one two three"<<std::endl;    inFS.close();}void AnalyzeText::fillKeyLocations(){               //fills keyLocations vector with vectors of ints for page numbers that the keywords appear on    for(int i = 0; i<keywordsOrdered.getNextOpen(); i++){        bool keyIsOnPage = false;        for(int x = 0; x<allPages.getNextOpen(); x++) {            keyIsOnPage = false;            DSVector<DSString> oneVec;            keyLocations.insert(oneVec);            for (int y = 0; y < allPages[x].getPageWords().getNextOpen(); y++) {                if (strstr(allPages[x].getPageWords()[y].makeLower().c_str(), keywordsOrdered[i].c_str()) != nullptr)                    keyIsOnPage = true;            }            if (keyIsOnPage) {                keyLocations[i].insert(allPages[x].getPageNum());            }        }    }}void AnalyzeText::orderOut() {          //Outputs the keywords and their page numbers in the correct format    std::ofstream outFS;    outFS.open(file3);    if(outFS.is_open())        std::cout<<"orderOut worked"<<std::endl;    else        std::cout<<"orderOut failed to open"<<std::endl;    DSString currLetter = keywordsOrdered[0].substring(0,1).makeUpper();    outFS<<"["<<currLetter<<"]"<<std::endl;    for(int i = 0; i<keywordsOrdered.getNextOpen(); i++) {        if (keywordsOrdered[i].substring(0, 1).makeUpper() != currLetter) {            currLetter = keywordsOrdered[i].substring(0, 1).makeUpper();            outFS << "[" << currLetter << "]" << std::endl;        }            DSString outputWord = keywordsOrdered[i] + ": ";            for (int x = 0; x < keyLocations[i].getNextOpen(); x++) {    //adds keyword and pages it appears on to one DSString                if (x != 0)                    outputWord = outputWord + ", ";                DSString pageInt;                outputWord = outputWord + keyLocations[i][x];            }            if (outputWord.getLength() > 70) {                          //wraps if the one line is greater than 70 characters                int count = 0;                while (count < outputWord.getLength()-70) {                    outFS << outputWord.substring(count, count+70);                    outFS<<std::endl<<"    ";                    count = count + 70;                }                outFS<<outputWord.substring(count,outputWord.getLength()-count)<<std::endl;            }            else                outFS<<outputWord<<std::endl;    }    outFS.close();}